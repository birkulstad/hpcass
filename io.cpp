#include "io.h"
#include "colormod.h" // namespace Color
#include <fstream>
#include <iomanip>
#include <iostream>

using namespace std;

/* Functions that are associated with writing outputs to the console and to files are stored in this file
 */

///@brief Call in a cout stream to change color to default for the console
Color::Modifier def(Color::FG_DEFAULT);
///@brief Call in a cout stream to change console output color to red
Color::Modifier red(Color::FG_RED);
///@brief Call in a cout stream to change console output  color to green
Color::Modifier green(Color::FG_GREEN);

///@brief Prints an [M x N] array of doubles to the console
void printMatrix(double* a, int M, int N){
    cout << "[";
    for (int i = 0; i < M; ++i){
        for (int j = 0; j < N; ++j){
            if (i + j >= 1){
                cout << ", ";
            };
            if ((j == 0) && (i > 0)){
                cout << endl;
            }
            cout << setw(8) << *(a + i * N + j);

        }

    }
    cout << "]" << endl;
}
///@brief Prints an [M x N] array of integers to the console
void printMatrix(int* a, int M, int N){
    cout << "[";
    for (int i = 0; i < M; ++i){
        for (int j = 0; j < N; ++j){
            if (i + j >= 1){
                cout << ", ";
            };
            if ((j == 0) && (i > 0)){
                cout << endl;
            }
            cout << setw(5) << *(a + i * N + j);

        }

    }
    cout << "]" << endl;
}
///@brief Throws an error message to the console and provides user with possible solutions
/**
 * @param e     Error number generated by an active if-statement check in the code.
 *
 * Default error is general.
 */
void errorMessage(int e){
    switch (e){
        default:
            cout << red << "ERROR! You probably did something bad" << def << endl;
            break;
        case (1):
            cout << red << "ERROR:  Real lengths must be positive!" << endl;
            cout << green << "Check command line input parameters 2, 3, 4, and 5." << def << endl;
            break;
        case (2):
            cout << red << "ERROR:  The mesh must be at least 2x2!" << endl;
            cout << green << "Check command line input parameters 6 and 7." << def << endl;
            break;
        case(3):
            cout << red << "ERROR:  The conductivity matrix D must be positive definite!" << endl;
            cout << green << "Check command line input parameters 8 and 9." << def << endl;
            cout << green << "D = [kxx, kxy; kxy, kyy]" << def << endl;
            break;
        case(4):
            cout << red << "Error! One or more of the BC edges are invalid" << endl;
            cout << green << "Check command line input parameters 11 and 12." << def << endl;
            cout << green << "0 = left, 1 = top, 2 = right, 3 = bottom" << def << endl;
            break;
        case(5):
            cout << red << "Error! The BCs can not be enforced at the same edge" << endl;
            cout << green << "Check command line input parameters 11 and 12." << def << endl;
            cout << green << "0 = left, 1 = top, 2 = right, 3 = bottom" << def << endl;
            break;
        case(6):
            cout << red << "Error! The dimensions do not produce a continuous object!" << endl;
            cout << green << "Check command line input parameters 1, 2, 3 and 4." << def << endl;
            cout << green << "Should have: a < 2 * (h1 + h2)/(L * (2 - L))" << def << endl;
            break;
    }
}


/// @brief Creates a VTK file of the solutions
void WriteVtkFile(int nnode_elem, int nnode, int nelem, double* Coord, int* ElemNode, double* T, int casenum) {
/**
 * @param nnode_elem    Number of elements per node
 * @param nnode         Total number of nodes
 * @param nelem         Total number of elements
 * @param Coord         [nnode x 2] List of [x,y]-values for each node (stored in row-major format)
 * @param ElemNode      [nelem x (nnode_elem + 1)] List of elements and their associated nodes
 * @param T             [1 x nnode] Array of nodal temperatures
 * @param casenum       Case associated with the solution (if not case 1, 2 or 3, will set to user defined). Used to generate .vtk filename
 */

    string filename;
    switch (casenum) {
        default:
            filename = "user_defined.vtk";
            break;
        case (1):
            filename = "case1.vtk";
            break;
        case (2):
            filename = "case2.vtk";
            break;
        case (3):
            filename = "case3.vtk";
            break;
    }

    ofstream vOut(filename, ios::out | ios::trunc); // Output file initialisation

    vOut.precision(10);

    // Title and info
    vOut << "# vtk DataFile Version 4.0" << endl; // VTK Version
    vOut << "vtk output" << endl;   // Stating output
    vOut << "ASCII" << endl;    // Format
    vOut << "DATASET UNSTRUCTURED_GRID" << endl;    // Dataset
    vOut << "POINTS " << nnode << " double" << endl; // Data type

    // Print nodal coordinates
    for (int i = 0; i < nnode ; i++) {
        // [x,y,z] (=0), separated by spaces
        vOut << Coord[2 * i] << " " << Coord[2 * i + 1] << " " << "0 ";
    }
    vOut << endl;

    vOut << "Cells " << nelem << " " << (nnode_elem + 1) * nelem << endl;

    // Print nodes of each element
    for (int i = 0; i < nelem; i++) {
        vOut << nnode_elem << " ";
        for (int j = 1; j < nnode_elem + 1; j++) {
            vOut << ElemNode[(nnode_elem + 1) * i + j] << " ";
        }
        vOut << endl;
    }

    // Print cell types as quadrilateral elements
    vOut << "CELL_TYPES " << nelem << endl;
    for (int i = 0; i < nelem; i++) {
        vOut << "9 " << endl;
    }
    // Adding metadata
    vOut << "POINT_DATA " << nnode << endl;
    vOut << "FIELD FieldData 1" << endl;
    vOut << "disp 1 " << nnode << " double" << endl;

    // Outputting temperature vector T
    for (int i = 0; i < nnode; i++) {
        vOut << T[i] << " ";
    }
    vOut.close();

}